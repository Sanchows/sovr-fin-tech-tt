# Notes
- В корне репозитория - инфраструктура, в `src` - проект.
- В данном проекте кастомизирована структура файлов и директорий: приложения находятся в `apps`; настройки и другие модули для работы Django - в `project`;
- В `apps` есть "абстрактное" приложение `common`, в котором хранятся сущности, которые могут быть переиспользованы в любом приложении
(абстрактные модели и другие сущности, кастомные исключения, вспомогательные функции utils и т.д.)
- Основное приложение - `sftapp`. Название выбрал не задумываясь (**sft** - современные финансовые тех-ии), в реальном мире - именуем в соответствии с доменной областью.
- Есть репозитории, через которые происходит взаимодействие с БД.
- Есть сервисный слой, в котором описана бизнес-логика.
- По CI/CD так же не стал усложнять с деплоем через docker compose (однако оставил Dockerfile), т.к. там нужно решать иные проблемы, которые далеки от задания (nginx, прокидывание директорий, писать entrypoint's, разделять локальный запуск с запуском на сервере и многое другое);
- Разделены переменные окружения по сервисам: `.env` - для приложения, `.env.postgresql` - для постгреса. Дабы случайно эти файлы не утекли в репозиторий - они добавлены в `.gitignore`, а в репозитории хранятся их templates (`.env.template`, `.env.postgresql.template`).

# Результат
- Решение 1 задания (организация моделей): `src/apps/sftapp/models.py`
    - **кредитная заявка**: модель `CreditApplication`;
    - **контракт**: модель `Contract`;
    - **товар**: модель `Product`;
    - **производитель**: модель `Manufacturer`;
    - **У кредитной заявки может быть только один контракт**: в модели `CreditApplication` OneToOne связь с `Contract`;
      - P.S. я уточнил этот момент и существование нескольких кредитных заявок с одним и тем же контрактом недопустимо, поэтому связь OneToOne.
    - **У кредитной заявки может быть несколько товаров; Каждый отдельно взятый товар связан только с одной заявкой**: модель `CreditApplicationProduct` для реализации связи между `CreditApplication` и `Product`;
      - P.S. насколько я понял эту формулировку, то это значит что один товар не может быть в разных заявках одновременно (иными словами - товары в разных кредитных заявках не могут пересекаться) - в модели `CreditApplicationProduct` поле `product` уникальное (= OneToOneField на `Product`)
    - **У товара только один производитель**: в модели `Product` ForeignKey на `Manufacturer`;
    - **"дата создания" у каждой модели есть поле**: абстрактная модель `CreatedAtModel` с полем `created_at`, от которой наследуем наши модели.
- Решение 2 задания (запрос): `src/apps/sftapp/services.py -> CreditApplicationService.get_unique_manufacturer_ids_by_contract_id` 
    - Достает **из множества объектов модели кредитной заявки** (с фильтром по id контракта) уникальные id производителей всех товаров.
        - работает за 1 SQL запрос.
        - фильтр по `contract_id` захардкожен (по ТЗ), можно добавить универсальности, принимать не `contract_id`, а, например, `*filters` и принимать Q фильтры извне, или `**kwargs`.
- **Для демонстрации решения заданий ТЗ реализованы тесты (src/apps/sftapp/tests.py), запуск через `python manage.py test`**

# How to run
1. Склонировать репозиторий к себе и перейти в корневую директорию репозитория.
2. Создать файл `.env.postgresql`, затем скопировать в него содержимое из `.env.postgresql.template`.
3. Создать файл `.env`, затем скопировать в него содержимое из `.env.template`.
4. Поднять PostgreSQL, используя docker compose:
  ```shell
  docker compose up -d
  ```
  - Если на вашей машине порт **5412** занят, измените в файле `docker-compose.yaml` портмаппинг с 5412 на свободный, а также значение переменной `DJANGO_DB_PORT` в файле `.env.postgresql`, затем снова поднимите PostgreSQL.
5. Убедится, что имя БД, пользователь и пароль в файле `.env` совпадают с значениями в `.env.postgresql`.
6. Перейти в директорию `src/`:
   ```shell
   cd src 
   ```
7. Создать виртуальное окружение, активировать и установить зависимости:
   ```shell
   python3 -m venv venv
   source venv/bin/activate
   pip install -r requirements.txt
   ```
8. Запуск проекта:
   - запуск проекта:
     ```shell
     python manage.py runserver
     ```
   - если нужна админка (http://localhost:8000/admin/), то собираем статику:
     ```shell
     python manage.py collectstatic --noinput
     ```
     и создаем супер пользователя (логин, email, пароль находятся в `.env`):
     ```shell
     python manage.py createsuperuser --noinput
     ```

# Спасибо за внимание! Если остались вопросы или что-то не так работает - tg: sanches005
